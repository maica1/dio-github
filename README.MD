# Git e Github üíª

## Intro

Git √© um sistema de versionamento de c√≥digo distribu√≠do, essencial para a organiza√ß√£o de um time √°gil que trabalha com qualquer tipo de c√≥digo.
Pilares do git:

* Controle de vers√µes
* Gerenciamento distribu√≠do
* Rastreabilidade
* Seguran√ßa

O Git consegue realizar o gerenciamento dos projetos, versionando diversos tipos de arquivos, sejam manuais em texto, imagens, arquivos de configura√ß√£o, scripts ou linhas de c√≥digo. O controle de versionamento destes arquivos garante rastreabilidade das mudan√ßas, facilidade de rollback, ou seja retornar a um estado seguro em caso de altera√ß√£o com erro e gerenciamento de conflitos quando existem times ou indiv√≠duos diferentes alterando um mesmo arquivo.

## Como o git funciona debaixo dos panos

O git realiza o derenciamento de altera√ß√µes atrav√©s de um algoritimo seguro de hash(SHA), no caso ele mantem o hash do arquivo salvo em um objeto e compara com o hash atual do arquivo, caso diferirem ele sabe que o arquivo foi alterado.

#### SHA - Secure Hash Algorithm

Como dito anteriormente, o sha √© um algoritimo de hash que retorna um valor _quase_ √∫nico que identifica o objeto em quest√£o. O algoritimo utilizado √© de 160 bits e n√£o √© poss√≠vel reverter o hash criado para o valor original que foi criptografado.

```shell
echo "conteudo" | sha1sum -
5b0d0dda479cc03cce59528e28961e498155f5c  -
echo "onteudo" | sha1sum -
8feae1c68dbdfb512ce8514d87e1efe913a3f1e1  -
```

Como podemos ver no exemplo acima, duas strings muito parecidas(diferen√ßa de um caracter) geram resultados totalmente aleat√≥rios e sem rela√ß√£o entre s√≠.

### **Objetos do git**

O git utiliza 3 tipos b√°sicos de objetos para gerenciar os projetos:

| Blob | Tree | Commit  |
|:-: |- |-
| ![Representa√ß√£o de um blob](images/blob_obj.png)  | ![Representa√ß√£o de uma tree](images/tree_obj.png)  | ![Representa√ß√£o de um commit](images/commit_obj.png)
| O Obejto blob tem o conte√∫do do arquivo + os metadados em sua composi√ß√£o (e isso √© levado em considera√ß√£o no hash como veremos abaixo)         Os metadados incluem o tipo de objeto, o tamanho, uma string \0 e o conte√∫do do arquivo.  | Armazenam blobs, e commits, ¬¥√© uma estrutura composta. Guarda o tipo de blob, tamanho, \0 nome do arquivo e hash dele Monta a estrutura de diretorios  | Objeto que agrega todas as altera√ß√µes realizadas, tem como metadados: tamanho, tree, parente(?commit?), autor, mensagem e timestamp
| `echo "conteudo" \| git hash-object --stdin fc31e91b26cf85a55e072476de7f263c89260eb1`  `echo -e "blob 9\0conteudo" \| sha1sum - fc31e91b26cf85a55e072476de7f263c89260eb1  -`  | Guarda as hashes dos arquivos e tem uma hash propria, ou seja, mudando um arquivo dentro do projeto, a tree ir√° ser alterada tambem  | Garante a rastreabilidade do sistema, com timestamp, as hashes, autor e mensagem do commit. Tamb√©m possui hash (fica no log)

<div style="text-align:center">

![alt](images/all_obj.png)

</div>

## Enough chating

Agora que j√° entendemos o que √© git e pra que ele serve, √© hora de faze-lo funcionar.

Em um diret√≥rio vazio damos o comando `git init` e o terminal nos retorna uma sa√≠da como `Initialized empty Git repository in /home/user/dir/.git/` indicando que criou o reposit√≥rio dentro do diret√≥rio .git, √© ali que a magia acontece. Dentro deste diret√≥rio encontramos a seguinte esturura:

```shell
ls -A 
branches  config  description  HEAD  hooks  info  objects  refs
```

No .git temos o diret√≥rio branches, um conceito tamb√©m fundamental que ser√° visto mais adiante, arquivo de configura√ß√µes que ser√° abordado no proximo paragrafo, description, HEAD que auxiliar√° no gerenciamento de altera√ß√µes de versionamento, diret√≥rio hooks, info, objects - que n√£o por acaso s√£o os blobs,trees e commits j√° estudados -, e diretorio refs.

Ap√≥s a inicializa√ß√£o do reposit√≥rio, devemos configura-lo, para isso usamos o comando `git config`, e parametrizamos ele de acordo com a necessidade. Falamos anteriormente que o objeto commit necessita armazenar mensagem, usuario e e-mail, iremos configurar agora alguns desses parametros.

`git config --global  user.name 'Maica1'` -> Nome de quem est√° utilizando o resposit√≥rio.

`git config --global user.email 'maicon.vieira@outlook.com.br'` - Email que identificar√° o usu√°rio

Dentro do diret√≥rio que foi inicializado o reposit√≥rio, come√ßamos a criar nosso projeto, criamos um arquivo e informamos ao git que ele ir√° gerenciar este arquivo, atrav√©s do comando `git add filename`, caso n√£o fizemos isso, o git saber√° que o arquivo est√° dentro do projeto, mas n√£o ir√° se preocupar com o gerenciamento deste como vemos a seguir:

```shell
git status
On branch master
No commits yet
Untracked files:
  (use "git add <file>..." to include in what will be committed)
  logs/
```

Este √© o status do projeto, com este comando conseguimos verificar conflitos, o que est√° sendo gerenciado e foi alterado, a√ß√µes a serem tomadas, etc.
Como o diretorio logs n√£o est√° sendo gerenciado, vamos fazer como instru√≠do e adiciona-lo ao projeto.

```shell
git status
On branch master


No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
new file:   logs/zoom_stdout_stderr.log
```

![Aprofundamento no gerencimanto de arquivos](images/tracking_state.png)

* Untracked - Arquivos que n√£o est√£o sendo gerenciados pelo git
* Tracked
  * Unmodified -> Arquivos gerenciados que n√£o foram alterados
  * Modified -> Arquivo gerenciado que tem sua SHA1 diferente da que consta na base do git, caracterizando uma modifica√ß√£o/altera√ß√£o no arquivo
  * Staged -> Arquivos prontos para serem commitados, vers√µes de release.

### Gerenciador de versionamento distribuido

Quando dizemos que o git √© um sistema distribuido de versionamento de c√≥digo, falamos pois √© realizada uma c√≥pia local dos dados do servidor, e no momento em que alteramos esta c√≥pia local as mudan√ßas n√£o se refletem autom√°ticamente no reposit√≥rio. H√° ent√£o o gerenciamento de altera√ß√µes comentado anteriormente que sinaliza e habilita as novas mudan√ßas para o reposit√≥rio remoto.

![alt](images/staging_areas.png)

* Working dir -> Arquivos n√£o modificados
* Staging area -> Arquivos aguardando commit
* Local repository -> arquivos que foram comitados

